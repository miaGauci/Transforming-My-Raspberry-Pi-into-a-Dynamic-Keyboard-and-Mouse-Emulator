Emulating a Keyboard and Mouse using a Raspberry Pi 
..

For reference go to: [https://github.com/thewh1teagle/zero-hid/tree/main/zero_hid]

When doing this project make sure that; 
- The files downloaded from the above link are calling the right classes 
  - by that I mean that it calls class 'Mouse' or 'Keyboard' 
  - these classes are of another python version (as per download) hence some methods are not found
  - because python calls the classes pre downloaded on it which can't be edited 
  - to see which class it is calling use the 'dir' function 

Information about USB mouse codes and connections;
[https://wiki.osdev.org/Mouse_Input]
Note: Every mouse when connected to a new device configures differently in its own way
  To find the hex codes that a mouse button sends when it is clicked; 
  Go to terminal and enter: **sudo usbhid-dump --entity=all**

Now
We know that these hex codes are obv in fact binary 
Binary represenation of usb mouse; 
Y overflow : X overflow : Y sign bit : X sign bit : Always 1 : Middle btn : Right btn : Left btn

Now the universal codes of the mouse are; 
Left btn : 0x01
Right btn : 0x02
Middle btn (scroll) : 0x04

!!!!
When you look at the binary rep of the usb mouse you can see where the binary bit fits and its hex representation 

Example we can see that the middle button is 0000100 ie 0x04

Now from the code snippet obtained from the link above 
```
send_mouse_event(self.dev, 0x0, 0, 0, 0, 0)
```
We can see that there are only 5 hex positions; 
\x(Button)\x(X Pos)\x(Y Pos)\x(Scroll Wheel)
However in our case we have another 0 
Note: the last 0 is for a mouse which would have a side scroll (yes they exist)

Now when it comes to **scrolling**
Scrolling coordinates are from 1 -> 255 
255 represented in hex is FF ie 
ScrollUp is 0x01 
ScrollDown is 0xFF

To clear mouse commands make sure to enter a delay using 'import time'
  0x0 is the hex to clear any buttons pressed 
  
Make sure that when you press a button you enter 0x0 to clear the command or else it will stay pressed 

```
def __init__(self):
  super().__init__()

def left_click(self):
#Note we still add the last 0 although it is unneccassary since the pi is programmed like that and it expects an input for that bit
  send_mouse_event(self.dev, 0x01, 0, 0, 0, 0)
  #or use the line time.sleep(Mouse__delay) where delay is initialised at the top (where Mouse is the class )
  #the __ are to create a local variable to the class 
  time.sleep(0.01)
  send_mouse_event(self.dev, 0x00, 0, 0, 0, 0)
  
```
from zero_hid import Mouse
import time
from zero_hid.hid.mouse import send_mouse_event
from typing import Union

class OMouse(Mouse):
    leftbutton = 0x01
    rightbutton = 0x2
    wheelbutton = 0x04
    noButtons = 0x0
    scrollUP = 0x01
    scrollDOWN = 0xFF
    __delay = 0.01
    
    def __init__(self):
        super().__init__()
        
    def left_click(self):
        send_mouse_event(self.dev, OMouse.leftbutton, 0, 0, 0, 0)
        time.sleep(stMouse.__delay)
        send_mouse_event(self.dev, OMouse.noButtons, 0, 0, 0, 0)
   
        
    def right_click(self):
        send_mouse_event(self.dev, OMouse.rightbutton, 0, 0, 0, 0)
        time.sleep()OMouse.__delay)
        send_mouse_event(self.dev, OMouse.noButtons, 0, 0, 0, 0)
        
    def scrollup(self):
        send_mouse_event(self.dev, 0, 0, 0, stMouse.scrollUP, 0)
        
    def scrolldown(self):
        send_mouse_event(self.dev, 0, 0, 0, stMouse.scrollDOWN, 0)
        
    def wheelClick(self):
        send_mouse_event(self.dev, stMouse.wheelbutton, 0, 0, 0, 0)
        time.sleep(0.01)
        send_mouse_event(self.dev, stMouse.noButtons, 0, 0, 0, 0)
        
        #?
        
    def createEvent(self, buttons:Union[int, list]=0, relX:int=0, relY:int=0, scroll:int=0):
        buttonsPressed = 0
        if type(buttons) == int:
            buttons = [buttons]
        for but in buttons:
            buttonsPressed |= but
        send_mouse_event(self.dev, buttonsPressed, relX, relY, scroll, 0)



if __name__ == "__main__":
    
    for i in range(1):
        m = OMouse()
        #m.move_relative(20,25)
        print("Wait for it")
        m.createEvent(OMouse.wheelbutton)
        m.createEvent(OMouse.wheelbutton, 10,10)
        m.createEvent()
        
        
        print("done")
        #the close is very important after right click as if right click is not used the program crashes 
        
 from zero_hid import Keyboard, KeyCodes
from zero_hid.hid.keyboard import send_keystroke, release_keys
from typing import Union


class -Keyboard(Keyboard):
    
    def __init__(self):
        super().__init__()
        
    def isconnected(self)-> bool:
        try:
            with open(self.dev, 'ab+') as hid_handle:
                hid_handle.write(bytearray([0]))
            return True
        except BlockingIOError:
            return False
    
    def press(self, mods: Union[int, list] , key_code: int=0, release=True)-> None:
        """
        Sends keystroked to PC. Including modifiers like CTRL
        """
        if type(mods) is list:
            if len(mods) == 1:
                mods = mods[0]
            else:
                allmods = 0
                for i in mods:
                    allmods |= i
                mods = allmods
        send_keystroke(self.dev, mods, key_code, release=release)

            
    def type_keys(self, text:str, delay=0)-> bool:
        try:
            self.type(text, delay)
            return True
        except:
            return False

   
if __name__ == "__main__":
    
    k = -Keyboard()
    if k.isconnected():
        print(k.isconnected())
        k.type_keys("A")
        print("Done")
    else:
        print("Please connect")

#     send_keystroke(k.dev, KeyCodes.MOD_LEFT_SHIFT, KeyCodes.KEY_A)
    #k.press([KeyCodes.MOD_LEFT_CONTROL, KeyCodes.MOD_LEFT_ALT], KeyCodes.KEY_DELETE)


